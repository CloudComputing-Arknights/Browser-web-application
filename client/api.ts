/* tslint:disable */
/* eslint-disable */
/**
 * Composite API
 * An API to orchestrate calls to other microservices.
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

export interface AddressDTO {
    'id'?: string | null;
    'street': string;
    'city': string;
    'country': string;
    'state'?: string | null;
    'postal_code'?: string | null;
    'created_at'?: string | null;
    'updated_at'?: string | null;
}
/**
 * Representation of a Category returned from the server.
 */
export interface CategoryRead {
    [key: string]: any;

    'name': string;
    'category_id': number;
    'description'?: string | null;
}

export const ConditionType = {
    BrandNew: 'BRAND_NEW',
    Good: 'GOOD',
    LikeNew: 'LIKE_NEW',
    Poor: 'POOR'
} as const;

export type ConditionType = typeof ConditionType[keyof typeof ConditionType];


/**
 * Request body from frontend.
 */
export interface CreateOwnItemReq {
    [key: string]: any;

    'title': string;
    'condition': ConditionType;
    'transaction_type': TransactionType;
    'price': number;
    'description'?: string | null;
    'address_UUID'?: string | null;
    'image_urls'?: Array<string> | null;
    'category_ids'?: Array<number> | null;
}


export interface CreateTransactionReq {
    'requested_item_id': string;
    'initiator_user_id': string;
    'receiver_user_id': string;
    'type': CreateTransactionReqTypeEnum;
    'offered_item_id'?: string | null;
    'offered_price'?: number | null;
    'status'?: CreateTransactionReqStatusEnum;
    'message'?: string | null;
}

export const CreateTransactionReqTypeEnum = {
    Trade: 'trade',
    Purchase: 'purchase'
} as const;

export type CreateTransactionReqTypeEnum = typeof CreateTransactionReqTypeEnum[keyof typeof CreateTransactionReqTypeEnum];
export const CreateTransactionReqStatusEnum = {
    Pending: 'pending',
    Accepted: 'accepted',
    Rejected: 'rejected',
    Canceled: 'canceled',
    Completed: 'completed'
} as const;

export type CreateTransactionReqStatusEnum = typeof CreateTransactionReqStatusEnum[keyof typeof CreateTransactionReqStatusEnum];

export interface HTTPValidationError {
    'detail'?: Array<ValidationError>;
}
/**
 * Server representation returned to clients.
 */
export interface ItemRead {
    [key: string]: any;

    'title': string;
    'condition': ConditionType;
    'transaction_type': TransactionType;
    'price': number;
    'description'?: string | null;
    'address_UUID'?: string | null;
    'image_urls'?: Array<string> | null;
    'item_UUID': string;
    'categories'?: Array<CategoryRead> | null;
    'created_at'?: string | null;
    'updated_at'?: string | null;
}


export interface JobRead {
    'job_UUID': string;
    'status': JobStatus;
    'item_UUID'?: string | null;
    'error_message'?: string | null;
}



export const JobStatus = {
    Pending: 'PENDING',
    Running: 'RUNNING',
    Completed: 'COMPLETED',
    Failed: 'FAILED'
} as const;

export type JobStatus = typeof JobStatus[keyof typeof JobStatus];


export interface SignInReq {
    'username': string;
    'password': string;
}
export interface SignInRes {
    'access_token': string;
    'token_type'?: string;
}
export interface SignUpReq {
    'username': string;
    'email': string;
    'password': string;
}
export interface SignedInUserRes {
    'id': string;
    'username': string;
    'email': string;
    'phone'?: string | null;
    'birth_date'?: string | null;
    'avatar_url'?: string | null;
    'addresses'?: Array<AddressDTO>;
    'created_at'?: string | null;
    'updated_at'?: string | null;
}
export interface TransactionRes {
    'transaction_id': string;
    'requested_item_id': string;
    'initiator_user_id': string;
    'receiver_user_id': string;
    'type': TransactionResTypeEnum;
    'offered_item_id'?: string | null;
    'offered_price'?: number | null;
    'status': TransactionResStatusEnum;
    'message'?: string | null;
    'created_at': string;
    'updated_at': string;
}

export const TransactionResTypeEnum = {
    Trade: 'trade',
    Purchase: 'purchase'
} as const;

export type TransactionResTypeEnum = typeof TransactionResTypeEnum[keyof typeof TransactionResTypeEnum];
export const TransactionResStatusEnum = {
    Pending: 'pending',
    Accepted: 'accepted',
    Rejected: 'rejected',
    Canceled: 'canceled',
    Completed: 'completed'
} as const;

export type TransactionResStatusEnum = typeof TransactionResStatusEnum[keyof typeof TransactionResStatusEnum];


export const TransactionType = {
    Rent: 'RENT',
    Sale: 'SALE'
} as const;

export type TransactionType = typeof TransactionType[keyof typeof TransactionType];


export interface UpdateOwnItemReq {
    [key: string]: any;

    'title'?: string | null;
    'condition'?: ConditionType | null;
    'transaction_type'?: TransactionType | null;
    'price'?: number | null;
    'description'?: string | null;
    'category_ids'?: Array<number> | null;
    'address_UUID'?: string | null;
    'image_urls'?: Array<string> | null;
}


export interface UpdateTransactionStatusReq {
    'status': UpdateTransactionStatusReqStatusEnum;
}

export const UpdateTransactionStatusReqStatusEnum = {
    Accepted: 'accepted',
    Rejected: 'rejected',
    Canceled: 'canceled',
    Completed: 'completed'
} as const;

export type UpdateTransactionStatusReqStatusEnum = typeof UpdateTransactionStatusReqStatusEnum[keyof typeof UpdateTransactionStatusReqStatusEnum];

export interface ValidationError {
    'loc': Array<ValidationErrorLocInner>;
    'msg': string;
    'type': string;
}
export interface ValidationErrorLocInner {
}

/**
 * DefaultApi - axios parameter creator
 */
export const DefaultApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Root
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rootGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultApi - functional programming interface
 */
export const DefaultApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DefaultApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Root
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rootGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rootGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.rootGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DefaultApi - factory interface
 */
export const DefaultApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DefaultApiFp(configuration)
    return {
        /**
         * 
         * @summary Root
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rootGet(options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.rootGet(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DefaultApi - object-oriented interface
 */
export class DefaultApi extends BaseAPI {
    /**
     * 
     * @summary Root
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public rootGet(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).rootGet(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ItemUserApi - axios parameter creator
 */
export const ItemUserApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create Item For Me
         * @param {CreateOwnItemReq} createOwnItemReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createItemForMeMeItemsPost: async (createOwnItemReq: CreateOwnItemReq, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createOwnItemReq' is not null or undefined
            assertParamExists('createItemForMeMeItemsPost', 'createOwnItemReq', createOwnItemReq)
            const localVarPath = `/me/items`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createOwnItemReq, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete My Item
         * @param {string} itemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMyItemMeItemsItemIdDelete: async (itemId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemId' is not null or undefined
            assertParamExists('deleteMyItemMeItemsItemIdDelete', 'itemId', itemId)
            const localVarPath = `/me/items/{item_id}`
                .replace(`{${"item_id"}}`, encodeURIComponent(String(itemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Check status of job, store item-user relation when job is COMPLETED
         * @param {string} jobId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMyJobStatusMeItemsJobsJobIdGet: async (jobId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'jobId' is not null or undefined
            assertParamExists('getMyJobStatusMeItemsJobsJobIdGet', 'jobId', jobId)
            const localVarPath = `/me/items/jobs/{job_id}`
                .replace(`{${"job_id"}}`, encodeURIComponent(String(jobId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List My Items
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMyItemsMeItemsGet: async (skip?: number, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/me/items`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update My Item
         * @param {string} itemId 
         * @param {string} ifMatch ETag required for concurrent update protection
         * @param {UpdateOwnItemReq} updateOwnItemReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMyItemMeItemsItemIdPatch: async (itemId: string, ifMatch: string, updateOwnItemReq: UpdateOwnItemReq, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemId' is not null or undefined
            assertParamExists('updateMyItemMeItemsItemIdPatch', 'itemId', itemId)
            // verify required parameter 'ifMatch' is not null or undefined
            assertParamExists('updateMyItemMeItemsItemIdPatch', 'ifMatch', ifMatch)
            // verify required parameter 'updateOwnItemReq' is not null or undefined
            assertParamExists('updateMyItemMeItemsItemIdPatch', 'updateOwnItemReq', updateOwnItemReq)
            const localVarPath = `/me/items/{item_id}`
                .replace(`{${"item_id"}}`, encodeURIComponent(String(itemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (ifMatch != null) {
                localVarHeaderParameter['If-Match'] = String(ifMatch);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateOwnItemReq, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ItemUserApi - functional programming interface
 */
export const ItemUserApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ItemUserApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create Item For Me
         * @param {CreateOwnItemReq} createOwnItemReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createItemForMeMeItemsPost(createOwnItemReq: CreateOwnItemReq, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JobRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createItemForMeMeItemsPost(createOwnItemReq, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemUserApi.createItemForMeMeItemsPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete My Item
         * @param {string} itemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteMyItemMeItemsItemIdDelete(itemId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteMyItemMeItemsItemIdDelete(itemId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemUserApi.deleteMyItemMeItemsItemIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Check status of job, store item-user relation when job is COMPLETED
         * @param {string} jobId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMyJobStatusMeItemsJobsJobIdGet(jobId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JobRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMyJobStatusMeItemsJobsJobIdGet(jobId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemUserApi.getMyJobStatusMeItemsJobsJobIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List My Items
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listMyItemsMeItemsGet(skip?: number, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listMyItemsMeItemsGet(skip, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemUserApi.listMyItemsMeItemsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update My Item
         * @param {string} itemId 
         * @param {string} ifMatch ETag required for concurrent update protection
         * @param {UpdateOwnItemReq} updateOwnItemReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateMyItemMeItemsItemIdPatch(itemId: string, ifMatch: string, updateOwnItemReq: UpdateOwnItemReq, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ItemRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateMyItemMeItemsItemIdPatch(itemId, ifMatch, updateOwnItemReq, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemUserApi.updateMyItemMeItemsItemIdPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ItemUserApi - factory interface
 */
export const ItemUserApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ItemUserApiFp(configuration)
    return {
        /**
         * 
         * @summary Create Item For Me
         * @param {CreateOwnItemReq} createOwnItemReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createItemForMeMeItemsPost(createOwnItemReq: CreateOwnItemReq, options?: RawAxiosRequestConfig): AxiosPromise<JobRead> {
            return localVarFp.createItemForMeMeItemsPost(createOwnItemReq, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete My Item
         * @param {string} itemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMyItemMeItemsItemIdDelete(itemId: string, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.deleteMyItemMeItemsItemIdDelete(itemId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Check status of job, store item-user relation when job is COMPLETED
         * @param {string} jobId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMyJobStatusMeItemsJobsJobIdGet(jobId: string, options?: RawAxiosRequestConfig): AxiosPromise<JobRead> {
            return localVarFp.getMyJobStatusMeItemsJobsJobIdGet(jobId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List My Items
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMyItemsMeItemsGet(skip?: number, limit?: number, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.listMyItemsMeItemsGet(skip, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update My Item
         * @param {string} itemId 
         * @param {string} ifMatch ETag required for concurrent update protection
         * @param {UpdateOwnItemReq} updateOwnItemReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMyItemMeItemsItemIdPatch(itemId: string, ifMatch: string, updateOwnItemReq: UpdateOwnItemReq, options?: RawAxiosRequestConfig): AxiosPromise<ItemRead> {
            return localVarFp.updateMyItemMeItemsItemIdPatch(itemId, ifMatch, updateOwnItemReq, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ItemUserApi - object-oriented interface
 */
export class ItemUserApi extends BaseAPI {
    /**
     * 
     * @summary Create Item For Me
     * @param {CreateOwnItemReq} createOwnItemReq 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createItemForMeMeItemsPost(createOwnItemReq: CreateOwnItemReq, options?: RawAxiosRequestConfig) {
        return ItemUserApiFp(this.configuration).createItemForMeMeItemsPost(createOwnItemReq, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete My Item
     * @param {string} itemId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteMyItemMeItemsItemIdDelete(itemId: string, options?: RawAxiosRequestConfig) {
        return ItemUserApiFp(this.configuration).deleteMyItemMeItemsItemIdDelete(itemId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Check status of job, store item-user relation when job is COMPLETED
     * @param {string} jobId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getMyJobStatusMeItemsJobsJobIdGet(jobId: string, options?: RawAxiosRequestConfig) {
        return ItemUserApiFp(this.configuration).getMyJobStatusMeItemsJobsJobIdGet(jobId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List My Items
     * @param {number} [skip] 
     * @param {number} [limit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listMyItemsMeItemsGet(skip?: number, limit?: number, options?: RawAxiosRequestConfig) {
        return ItemUserApiFp(this.configuration).listMyItemsMeItemsGet(skip, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update My Item
     * @param {string} itemId 
     * @param {string} ifMatch ETag required for concurrent update protection
     * @param {UpdateOwnItemReq} updateOwnItemReq 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public updateMyItemMeItemsItemIdPatch(itemId: string, ifMatch: string, updateOwnItemReq: UpdateOwnItemReq, options?: RawAxiosRequestConfig) {
        return ItemUserApiFp(this.configuration).updateMyItemMeItemsItemIdPatch(itemId, ifMatch, updateOwnItemReq, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ItemsApi - axios parameter creator
 */
export const ItemsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get an item by its id
         * @summary Get an item by its id
         * @param {string} itemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPublicItemByIdItemsItemIdGet: async (itemId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemId' is not null or undefined
            assertParamExists('getPublicItemByIdItemsItemIdGet', 'itemId', itemId)
            const localVarPath = `/items/{item_id}`
                .replace(`{${"item_id"}}`, encodeURIComponent(String(itemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Categories
         * @param {number} [skip] Number of items to skip
         * @param {number} [limit] Max number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCategoriesItemsCategoriesGet: async (skip?: number, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/items/categories`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get items through pagination, can be filtered by ID, category, condition, transaction type
         * @summary Get items through pagination.
         * @param {Array<string> | null} [id] Filter by a list of item IDs
         * @param {number | null} [categoryId] Filter by item\&#39;s category
         * @param {TransactionType | null} [transactionType] Filter by item\&#39;s transaction type
         * @param {string | null} [search] Search by item title (case-insensitive, partial match)
         * @param {number} [skip] Number of items to skip
         * @param {number} [limit] Max number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPublicItemsItemsGet: async (id?: Array<string> | null, categoryId?: number | null, transactionType?: TransactionType | null, search?: string | null, skip?: number, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/items/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (id) {
                localVarQueryParameter['id'] = id;
            }

            if (categoryId !== undefined) {
                localVarQueryParameter['category_id'] = categoryId;
            }

            if (transactionType !== undefined) {
                localVarQueryParameter['transaction_type'] = transactionType;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ItemsApi - functional programming interface
 */
export const ItemsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ItemsApiAxiosParamCreator(configuration)
    return {
        /**
         * Get an item by its id
         * @summary Get an item by its id
         * @param {string} itemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPublicItemByIdItemsItemIdGet(itemId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ItemRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPublicItemByIdItemsItemIdGet(itemId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemsApi.getPublicItemByIdItemsItemIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List Categories
         * @param {number} [skip] Number of items to skip
         * @param {number} [limit] Max number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listCategoriesItemsCategoriesGet(skip?: number, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CategoryRead>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listCategoriesItemsCategoriesGet(skip, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemsApi.listCategoriesItemsCategoriesGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get items through pagination, can be filtered by ID, category, condition, transaction type
         * @summary Get items through pagination.
         * @param {Array<string> | null} [id] Filter by a list of item IDs
         * @param {number | null} [categoryId] Filter by item\&#39;s category
         * @param {TransactionType | null} [transactionType] Filter by item\&#39;s transaction type
         * @param {string | null} [search] Search by item title (case-insensitive, partial match)
         * @param {number} [skip] Number of items to skip
         * @param {number} [limit] Max number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listPublicItemsItemsGet(id?: Array<string> | null, categoryId?: number | null, transactionType?: TransactionType | null, search?: string | null, skip?: number, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ItemRead>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listPublicItemsItemsGet(id, categoryId, transactionType, search, skip, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemsApi.listPublicItemsItemsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ItemsApi - factory interface
 */
export const ItemsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ItemsApiFp(configuration)
    return {
        /**
         * Get an item by its id
         * @summary Get an item by its id
         * @param {string} itemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPublicItemByIdItemsItemIdGet(itemId: string, options?: RawAxiosRequestConfig): AxiosPromise<ItemRead> {
            return localVarFp.getPublicItemByIdItemsItemIdGet(itemId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Categories
         * @param {number} [skip] Number of items to skip
         * @param {number} [limit] Max number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCategoriesItemsCategoriesGet(skip?: number, limit?: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<CategoryRead>> {
            return localVarFp.listCategoriesItemsCategoriesGet(skip, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Get items through pagination, can be filtered by ID, category, condition, transaction type
         * @summary Get items through pagination.
         * @param {Array<string> | null} [id] Filter by a list of item IDs
         * @param {number | null} [categoryId] Filter by item\&#39;s category
         * @param {TransactionType | null} [transactionType] Filter by item\&#39;s transaction type
         * @param {string | null} [search] Search by item title (case-insensitive, partial match)
         * @param {number} [skip] Number of items to skip
         * @param {number} [limit] Max number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPublicItemsItemsGet(id?: Array<string> | null, categoryId?: number | null, transactionType?: TransactionType | null, search?: string | null, skip?: number, limit?: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<ItemRead>> {
            return localVarFp.listPublicItemsItemsGet(id, categoryId, transactionType, search, skip, limit, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ItemsApi - object-oriented interface
 */
export class ItemsApi extends BaseAPI {
    /**
     * Get an item by its id
     * @summary Get an item by its id
     * @param {string} itemId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getPublicItemByIdItemsItemIdGet(itemId: string, options?: RawAxiosRequestConfig) {
        return ItemsApiFp(this.configuration).getPublicItemByIdItemsItemIdGet(itemId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List Categories
     * @param {number} [skip] Number of items to skip
     * @param {number} [limit] Max number of items to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listCategoriesItemsCategoriesGet(skip?: number, limit?: number, options?: RawAxiosRequestConfig) {
        return ItemsApiFp(this.configuration).listCategoriesItemsCategoriesGet(skip, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get items through pagination, can be filtered by ID, category, condition, transaction type
     * @summary Get items through pagination.
     * @param {Array<string> | null} [id] Filter by a list of item IDs
     * @param {number | null} [categoryId] Filter by item\&#39;s category
     * @param {TransactionType | null} [transactionType] Filter by item\&#39;s transaction type
     * @param {string | null} [search] Search by item title (case-insensitive, partial match)
     * @param {number} [skip] Number of items to skip
     * @param {number} [limit] Max number of items to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listPublicItemsItemsGet(id?: Array<string> | null, categoryId?: number | null, transactionType?: TransactionType | null, search?: string | null, skip?: number, limit?: number, options?: RawAxiosRequestConfig) {
        return ItemsApiFp(this.configuration).listPublicItemsItemsGet(id, categoryId, transactionType, search, skip, limit, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TransactionApi - axios parameter creator
 */
export const TransactionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create Transaction
         * @param {CreateTransactionReq} createTransactionReq 
         * @param {string | null} [xIdempotencyKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTransactionTransactionsTransactionPost: async (createTransactionReq: CreateTransactionReq, xIdempotencyKey?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createTransactionReq' is not null or undefined
            assertParamExists('createTransactionTransactionsTransactionPost', 'createTransactionReq', createTransactionReq)
            const localVarPath = `/transactions/transaction`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (xIdempotencyKey != null) {
                localVarHeaderParameter['X-Idempotency-Key'] = String(xIdempotencyKey);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createTransactionReq, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Transaction
         * @param {string} transactionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTransactionTransactionsTransactionIdDelete: async (transactionId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'transactionId' is not null or undefined
            assertParamExists('deleteTransactionTransactionsTransactionIdDelete', 'transactionId', transactionId)
            const localVarPath = `/transactions/{transaction_id}`
                .replace(`{${"transaction_id"}}`, encodeURIComponent(String(transactionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Transaction
         * @param {string} transactionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionTransactionsTransactionIdGet: async (transactionId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'transactionId' is not null or undefined
            assertParamExists('getTransactionTransactionsTransactionIdGet', 'transactionId', transactionId)
            const localVarPath = `/transactions/{transaction_id}`
                .replace(`{${"transaction_id"}}`, encodeURIComponent(String(transactionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Transactions
         * @param {ListTransactionsTransactionsGetStatusParamEnum} [statusParam] 
         * @param {string | null} [initiatorUserId] 
         * @param {string | null} [receiverUserId] 
         * @param {string | null} [requestedItemId] 
         * @param {ListTransactionsTransactionsGetTypeEnum} [type] 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTransactionsTransactionsGet: async (statusParam?: ListTransactionsTransactionsGetStatusParamEnum, initiatorUserId?: string | null, receiverUserId?: string | null, requestedItemId?: string | null, type?: ListTransactionsTransactionsGetTypeEnum, limit?: number, offset?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/transactions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (statusParam !== undefined) {
                localVarQueryParameter['status_param'] = statusParam;
            }

            if (initiatorUserId !== undefined) {
                localVarQueryParameter['initiator_user_id'] = initiatorUserId;
            }

            if (receiverUserId !== undefined) {
                localVarQueryParameter['receiver_user_id'] = receiverUserId;
            }

            if (requestedItemId !== undefined) {
                localVarQueryParameter['requested_item_id'] = requestedItemId;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update Transaction
         * @param {string} transactionId 
         * @param {UpdateTransactionStatusReq} updateTransactionStatusReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTransactionTransactionsTransactionIdPut: async (transactionId: string, updateTransactionStatusReq: UpdateTransactionStatusReq, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'transactionId' is not null or undefined
            assertParamExists('updateTransactionTransactionsTransactionIdPut', 'transactionId', transactionId)
            // verify required parameter 'updateTransactionStatusReq' is not null or undefined
            assertParamExists('updateTransactionTransactionsTransactionIdPut', 'updateTransactionStatusReq', updateTransactionStatusReq)
            const localVarPath = `/transactions/{transaction_id}`
                .replace(`{${"transaction_id"}}`, encodeURIComponent(String(transactionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateTransactionStatusReq, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TransactionApi - functional programming interface
 */
export const TransactionApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TransactionApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create Transaction
         * @param {CreateTransactionReq} createTransactionReq 
         * @param {string | null} [xIdempotencyKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTransactionTransactionsTransactionPost(createTransactionReq: CreateTransactionReq, xIdempotencyKey?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionRes>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createTransactionTransactionsTransactionPost(createTransactionReq, xIdempotencyKey, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TransactionApi.createTransactionTransactionsTransactionPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete Transaction
         * @param {string} transactionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteTransactionTransactionsTransactionIdDelete(transactionId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionRes>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteTransactionTransactionsTransactionIdDelete(transactionId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TransactionApi.deleteTransactionTransactionsTransactionIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Transaction
         * @param {string} transactionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTransactionTransactionsTransactionIdGet(transactionId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionRes>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTransactionTransactionsTransactionIdGet(transactionId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TransactionApi.getTransactionTransactionsTransactionIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List Transactions
         * @param {ListTransactionsTransactionsGetStatusParamEnum} [statusParam] 
         * @param {string | null} [initiatorUserId] 
         * @param {string | null} [receiverUserId] 
         * @param {string | null} [requestedItemId] 
         * @param {ListTransactionsTransactionsGetTypeEnum} [type] 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listTransactionsTransactionsGet(statusParam?: ListTransactionsTransactionsGetStatusParamEnum, initiatorUserId?: string | null, receiverUserId?: string | null, requestedItemId?: string | null, type?: ListTransactionsTransactionsGetTypeEnum, limit?: number, offset?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TransactionRes>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listTransactionsTransactionsGet(statusParam, initiatorUserId, receiverUserId, requestedItemId, type, limit, offset, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TransactionApi.listTransactionsTransactionsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update Transaction
         * @param {string} transactionId 
         * @param {UpdateTransactionStatusReq} updateTransactionStatusReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateTransactionTransactionsTransactionIdPut(transactionId: string, updateTransactionStatusReq: UpdateTransactionStatusReq, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionRes>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateTransactionTransactionsTransactionIdPut(transactionId, updateTransactionStatusReq, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TransactionApi.updateTransactionTransactionsTransactionIdPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TransactionApi - factory interface
 */
export const TransactionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TransactionApiFp(configuration)
    return {
        /**
         * 
         * @summary Create Transaction
         * @param {CreateTransactionReq} createTransactionReq 
         * @param {string | null} [xIdempotencyKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTransactionTransactionsTransactionPost(createTransactionReq: CreateTransactionReq, xIdempotencyKey?: string | null, options?: RawAxiosRequestConfig): AxiosPromise<TransactionRes> {
            return localVarFp.createTransactionTransactionsTransactionPost(createTransactionReq, xIdempotencyKey, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete Transaction
         * @param {string} transactionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTransactionTransactionsTransactionIdDelete(transactionId: string, options?: RawAxiosRequestConfig): AxiosPromise<TransactionRes> {
            return localVarFp.deleteTransactionTransactionsTransactionIdDelete(transactionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Transaction
         * @param {string} transactionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionTransactionsTransactionIdGet(transactionId: string, options?: RawAxiosRequestConfig): AxiosPromise<TransactionRes> {
            return localVarFp.getTransactionTransactionsTransactionIdGet(transactionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Transactions
         * @param {ListTransactionsTransactionsGetStatusParamEnum} [statusParam] 
         * @param {string | null} [initiatorUserId] 
         * @param {string | null} [receiverUserId] 
         * @param {string | null} [requestedItemId] 
         * @param {ListTransactionsTransactionsGetTypeEnum} [type] 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTransactionsTransactionsGet(statusParam?: ListTransactionsTransactionsGetStatusParamEnum, initiatorUserId?: string | null, receiverUserId?: string | null, requestedItemId?: string | null, type?: ListTransactionsTransactionsGetTypeEnum, limit?: number, offset?: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<TransactionRes>> {
            return localVarFp.listTransactionsTransactionsGet(statusParam, initiatorUserId, receiverUserId, requestedItemId, type, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update Transaction
         * @param {string} transactionId 
         * @param {UpdateTransactionStatusReq} updateTransactionStatusReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTransactionTransactionsTransactionIdPut(transactionId: string, updateTransactionStatusReq: UpdateTransactionStatusReq, options?: RawAxiosRequestConfig): AxiosPromise<TransactionRes> {
            return localVarFp.updateTransactionTransactionsTransactionIdPut(transactionId, updateTransactionStatusReq, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TransactionApi - object-oriented interface
 */
export class TransactionApi extends BaseAPI {
    /**
     * 
     * @summary Create Transaction
     * @param {CreateTransactionReq} createTransactionReq 
     * @param {string | null} [xIdempotencyKey] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createTransactionTransactionsTransactionPost(createTransactionReq: CreateTransactionReq, xIdempotencyKey?: string | null, options?: RawAxiosRequestConfig) {
        return TransactionApiFp(this.configuration).createTransactionTransactionsTransactionPost(createTransactionReq, xIdempotencyKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete Transaction
     * @param {string} transactionId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteTransactionTransactionsTransactionIdDelete(transactionId: string, options?: RawAxiosRequestConfig) {
        return TransactionApiFp(this.configuration).deleteTransactionTransactionsTransactionIdDelete(transactionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Transaction
     * @param {string} transactionId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getTransactionTransactionsTransactionIdGet(transactionId: string, options?: RawAxiosRequestConfig) {
        return TransactionApiFp(this.configuration).getTransactionTransactionsTransactionIdGet(transactionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List Transactions
     * @param {ListTransactionsTransactionsGetStatusParamEnum} [statusParam] 
     * @param {string | null} [initiatorUserId] 
     * @param {string | null} [receiverUserId] 
     * @param {string | null} [requestedItemId] 
     * @param {ListTransactionsTransactionsGetTypeEnum} [type] 
     * @param {number} [limit] 
     * @param {number} [offset] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listTransactionsTransactionsGet(statusParam?: ListTransactionsTransactionsGetStatusParamEnum, initiatorUserId?: string | null, receiverUserId?: string | null, requestedItemId?: string | null, type?: ListTransactionsTransactionsGetTypeEnum, limit?: number, offset?: number, options?: RawAxiosRequestConfig) {
        return TransactionApiFp(this.configuration).listTransactionsTransactionsGet(statusParam, initiatorUserId, receiverUserId, requestedItemId, type, limit, offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update Transaction
     * @param {string} transactionId 
     * @param {UpdateTransactionStatusReq} updateTransactionStatusReq 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public updateTransactionTransactionsTransactionIdPut(transactionId: string, updateTransactionStatusReq: UpdateTransactionStatusReq, options?: RawAxiosRequestConfig) {
        return TransactionApiFp(this.configuration).updateTransactionTransactionsTransactionIdPut(transactionId, updateTransactionStatusReq, options).then((request) => request(this.axios, this.basePath));
    }
}

export const ListTransactionsTransactionsGetStatusParamEnum = {
    Pending: 'pending',
    Accepted: 'accepted',
    Rejected: 'rejected',
    Canceled: 'canceled',
    Completed: 'completed'
} as const;
export type ListTransactionsTransactionsGetStatusParamEnum = typeof ListTransactionsTransactionsGetStatusParamEnum[keyof typeof ListTransactionsTransactionsGetStatusParamEnum];
export const ListTransactionsTransactionsGetTypeEnum = {
    Trade: 'trade',
    Purchase: 'purchase'
} as const;
export type ListTransactionsTransactionsGetTypeEnum = typeof ListTransactionsTransactionsGetTypeEnum[keyof typeof ListTransactionsTransactionsGetTypeEnum];


/**
 * UserApi - axios parameter creator
 */
export const UserApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Auth Me
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authMeMeUserGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/me/user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create User
         * @param {SignUpReq} signUpReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserUsersPost: async (signUpReq: SignUpReq, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'signUpReq' is not null or undefined
            assertParamExists('createUserUsersPost', 'signUpReq', signUpReq)
            const localVarPath = `/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(signUpReq, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Sign In
         * @param {SignInReq} signInReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signInTokenPost: async (signInReq: SignInReq, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'signInReq' is not null or undefined
            assertParamExists('signInTokenPost', 'signInReq', signInReq)
            const localVarPath = `/token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(signInReq, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserApi - functional programming interface
 */
export const UserApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Auth Me
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authMeMeUserGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SignedInUserRes>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authMeMeUserGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.authMeMeUserGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create User
         * @param {SignUpReq} signUpReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createUserUsersPost(signUpReq: SignUpReq, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SignedInUserRes>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createUserUsersPost(signUpReq, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.createUserUsersPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Sign In
         * @param {SignInReq} signInReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async signInTokenPost(signInReq: SignInReq, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SignInRes>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.signInTokenPost(signInReq, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.signInTokenPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UserApi - factory interface
 */
export const UserApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserApiFp(configuration)
    return {
        /**
         * 
         * @summary Auth Me
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authMeMeUserGet(options?: RawAxiosRequestConfig): AxiosPromise<SignedInUserRes> {
            return localVarFp.authMeMeUserGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create User
         * @param {SignUpReq} signUpReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserUsersPost(signUpReq: SignUpReq, options?: RawAxiosRequestConfig): AxiosPromise<SignedInUserRes> {
            return localVarFp.createUserUsersPost(signUpReq, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Sign In
         * @param {SignInReq} signInReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signInTokenPost(signInReq: SignInReq, options?: RawAxiosRequestConfig): AxiosPromise<SignInRes> {
            return localVarFp.signInTokenPost(signInReq, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserApi - object-oriented interface
 */
export class UserApi extends BaseAPI {
    /**
     * 
     * @summary Auth Me
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public authMeMeUserGet(options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).authMeMeUserGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create User
     * @param {SignUpReq} signUpReq 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createUserUsersPost(signUpReq: SignUpReq, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).createUserUsersPost(signUpReq, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Sign In
     * @param {SignInReq} signInReq 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public signInTokenPost(signInReq: SignInReq, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).signInTokenPost(signInReq, options).then((request) => request(this.axios, this.basePath));
    }
}



